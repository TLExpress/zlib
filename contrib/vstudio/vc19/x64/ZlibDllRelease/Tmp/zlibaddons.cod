; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28805.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	uncompress3
PUBLIC	uncompress4
PUBLIC	compress3
PUBLIC	compress4
;	COMDAT pdata
pdata	SEGMENT
$pdata$uncompress3 DD imagerel $LN4
	DD	imagerel $LN4+32
	DD	imagerel $unwind$uncompress3
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$uncompress4 DD imagerel $LN29
	DD	imagerel $LN29+126
	DD	imagerel $unwind$uncompress4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$uncompress4 DD imagerel $LN29+126
	DD	imagerel $LN29+324
	DD	imagerel $chain$0$uncompress4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$uncompress4 DD imagerel $LN29+324
	DD	imagerel $LN29+353
	DD	imagerel $chain$1$uncompress4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compress3 DD imagerel $LN4
	DD	imagerel $LN4+30
	DD	imagerel $unwind$compress3
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compress4 DD imagerel $LN17
	DD	imagerel $LN17+286
	DD	imagerel $unwind$compress4
;	COMDAT xdata
xdata	SEGMENT
$unwind$compress4 DD 0b1b01H
	DD	01a641bH
	DD	019541bH
	DD	018341bH
	DD	014011bH
	DD	0e012f014H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compress3 DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$uncompress4 DD 021H
	DD	imagerel $LN29
	DD	imagerel $LN29+126
	DD	imagerel $unwind$uncompress4
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$uncompress4 DD 020821H
	DD	0183408H
	DD	imagerel $LN29
	DD	imagerel $LN29+126
	DD	imagerel $unwind$uncompress4
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$uncompress4 DD 0b1a01H
	DD	01a641aH
	DD	019541aH
	DD	012011aH
	DD	0e011f013H
	DD	0c00dd00fH
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$uncompress3 DD 010901H
	DD	06209H
; Function compile flags: /Ogtpy
; File C:\Users\hank2\source\repos\zlib\zlibaddons.c
;	COMDAT compress4
_TEXT	SEGMENT
stream$ = 64
dest$ = 192
destLen$ = 200
source$ = 208
sourceLen$ = 216
level$ = 224
windowBits$ = 232
compress4 PROC						; COMDAT

; 11   : {

$LN17:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H

; 12   :     z_stream stream;
; 13   :     int err;
; 14   :     const uInt max = (uInt)-1;
; 15   :     uLong left;
; 16   : 
; 17   :     left = *destLen;

  0001b	8b 3a		 mov	 edi, DWORD PTR [rdx]

; 18   :     *destLen = 0;

  0001d	45 33 ff	 xor	 r15d, r15d

; 19   : 
; 20   :     stream.zalloc = (alloc_func)0;
; 21   :     stream.zfree = (free_func)0;
; 22   :     stream.opaque = (voidpf)0;
; 23   : 
; 24   :     err = deflateInit2(&stream, level, Z_DEFLATED, windowBits, MAX_MEM_LEVEL, Z_DEFAULT_STRATEGY);

  00020	c7 40 80 58 00
	00 00		 mov	 DWORD PTR [rax-128], 88	; 00000058H
  00027	41 8b d9	 mov	 ebx, r9d
  0002a	44 8b 8c 24 e8
	00 00 00	 mov	 r9d, DWORD PTR windowBits$[rsp]
  00032	49 8b f0	 mov	 rsi, r8
  00035	4c 89 78 b8	 mov	 QWORD PTR [rax-72], r15
  00039	4c 8b f2	 mov	 r14, rdx
  0003c	4c 89 78 c0	 mov	 QWORD PTR [rax-64], r15
  00040	45 8d 47 08	 lea	 r8d, QWORD PTR [r15+8]
  00044	4c 89 78 c8	 mov	 QWORD PTR [rax-56], r15
  00048	48 8b e9	 mov	 rbp, rcx
  0004b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06CJNJFBNP@1?42?411@
  00052	44 89 3a	 mov	 DWORD PTR [rdx], r15d
  00055	8b 94 24 e0 00
	00 00		 mov	 edx, DWORD PTR level$[rsp]
  0005c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR stream$[rsp]
  00061	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00066	44 89 7c 24 28	 mov	 DWORD PTR [rsp+40], r15d
  0006b	c7 44 24 20 09
	00 00 00	 mov	 DWORD PTR [rsp+32], 9
  00073	e8 00 00 00 00	 call	 deflateInit2_

; 25   :     if (err != Z_OK) return err;

  00078	85 c0		 test	 eax, eax
  0007a	0f 85 81 00 00
	00		 jne	 $LN1@compress4

; 26   : 
; 27   :     stream.next_out = dest;
; 28   :     stream.avail_out = 0;

  00080	41 8b c7	 mov	 eax, r15d
  00083	48 89 6c 24 50	 mov	 QWORD PTR stream$[rsp+16], rbp

; 29   :     stream.next_in = (z_const Bytef*)source;
; 30   :     stream.avail_in = 0;

  00088	41 8b cf	 mov	 ecx, r15d
  0008b	89 44 24 58	 mov	 DWORD PTR stream$[rsp+24], eax
  0008f	89 4c 24 48	 mov	 DWORD PTR stream$[rsp+8], ecx
  00093	bd ff ff ff ff	 mov	 ebp, -1			; ffffffffH
  00098	48 89 74 24 40	 mov	 QWORD PTR stream$[rsp], rsi
  0009d	0f 1f 00	 npad	 3
$LL4@compress4:

; 31   : 
; 32   :     do {
; 33   :         if (stream.avail_out == 0) {

  000a0	85 c0		 test	 eax, eax
  000a2	75 0d		 jne	 SHORT $LN6@compress4

; 34   :             stream.avail_out = left > (uLong)max ? max : (uInt)left;

  000a4	3b fd		 cmp	 edi, ebp
  000a6	8b c7		 mov	 eax, edi
  000a8	0f 47 c5	 cmova	 eax, ebp
  000ab	89 44 24 58	 mov	 DWORD PTR stream$[rsp+24], eax

; 35   :             left -= stream.avail_out;

  000af	2b f8		 sub	 edi, eax
$LN6@compress4:

; 36   :         }
; 37   :         if (stream.avail_in == 0) {

  000b1	85 c9		 test	 ecx, ecx
  000b3	75 0d		 jne	 SHORT $LN7@compress4

; 38   :             stream.avail_in = sourceLen > (uLong)max ? max : (uInt)sourceLen;

  000b5	3b dd		 cmp	 ebx, ebp
  000b7	8b c3		 mov	 eax, ebx
  000b9	0f 47 c5	 cmova	 eax, ebp
  000bc	89 44 24 48	 mov	 DWORD PTR stream$[rsp+8], eax

; 39   :             sourceLen -= stream.avail_in;

  000c0	2b d8		 sub	 ebx, eax
$LN7@compress4:

; 40   :         }
; 41   :         err = deflate(&stream, sourceLen ? Z_NO_FLUSH : Z_FINISH);

  000c2	ba 04 00 00 00	 mov	 edx, 4
  000c7	48 8d 4c 24 40	 lea	 rcx, QWORD PTR stream$[rsp]
  000cc	85 db		 test	 ebx, ebx
  000ce	41 0f 45 d7	 cmovne	 edx, r15d
  000d2	e8 00 00 00 00	 call	 deflate
  000d7	8b f0		 mov	 esi, eax

; 42   :     } while (err == Z_OK);

  000d9	85 c0		 test	 eax, eax
  000db	75 0a		 jne	 SHORT $LN15@compress4
  000dd	8b 44 24 58	 mov	 eax, DWORD PTR stream$[rsp+24]
  000e1	8b 4c 24 48	 mov	 ecx, DWORD PTR stream$[rsp+8]
  000e5	eb b9		 jmp	 SHORT $LL4@compress4
$LN15@compress4:

; 43   : 
; 44   :     *destLen = stream.total_out;

  000e7	8b 44 24 5c	 mov	 eax, DWORD PTR stream$[rsp+28]

; 45   :     deflateEnd(&stream);

  000eb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR stream$[rsp]
  000f0	41 89 06	 mov	 DWORD PTR [r14], eax
  000f3	e8 00 00 00 00	 call	 deflateEnd

; 46   :     return err == Z_STREAM_END ? Z_OK : err;

  000f8	83 fe 01	 cmp	 esi, 1
  000fb	41 0f 44 f7	 cmove	 esi, r15d
  000ff	8b c6		 mov	 eax, esi
$LN1@compress4:

; 47   : }

  00101	4c 8d 9c 24 a0
	00 00 00	 lea	 r11, QWORD PTR [rsp+160]
  00109	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  0010d	49 8b 6b 28	 mov	 rbp, QWORD PTR [r11+40]
  00111	49 8b 73 30	 mov	 rsi, QWORD PTR [r11+48]
  00115	49 8b e3	 mov	 rsp, r11
  00118	41 5f		 pop	 r15
  0011a	41 5e		 pop	 r14
  0011c	5f		 pop	 rdi
  0011d	c3		 ret	 0
compress4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\hank2\source\repos\zlib\zlibaddons.c
;	COMDAT compress3
_TEXT	SEGMENT
dest$ = 64
destLen$ = 72
source$ = 80
sourceLen$ = 88
windowBits$ = 96
compress3 PROC						; COMDAT

; 55   : {

$LN4:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 56   :     return compress4(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION, windowBits);

  00004	8b 44 24 60	 mov	 eax, DWORD PTR windowBits$[rsp]
  00008	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0000c	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR [rsp+32], -1
  00014	e8 00 00 00 00	 call	 compress4

; 57   : }

  00019	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001d	c3		 ret	 0
compress3 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\hank2\source\repos\zlib\zlibaddons.c
;	COMDAT uncompress4
_TEXT	SEGMENT
buf$ = 32
stream$ = 48
dest$ = 192
destLen$ = 200
source$ = 208
sourceLen$ = 216
windowBits$ = 224
uncompress4 PROC					; COMDAT

; 65   : {

$LN29:
  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	41 56		 push	 r14
  00011	41 57		 push	 r15
  00013	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H

; 66   :     z_stream stream;
; 67   :     int err;
; 68   :     const uInt max = (uInt)-1;
; 69   :     uLong len, left;
; 70   :     Byte buf[1];    /* for detection of incomplete stream when *destLen == 0 */
; 71   : 
; 72   :     len = *sourceLen;
; 73   :     if (*destLen) {

  0001a	8b 3a		 mov	 edi, DWORD PTR [rdx]
  0001c	33 ed		 xor	 ebp, ebp
  0001e	41 8b 31	 mov	 esi, DWORD PTR [r9]
  00021	4d 8b e9	 mov	 r13, r9
  00024	4c 8b e2	 mov	 r12, rdx
  00027	4c 8b f9	 mov	 r15, rcx
  0002a	44 8d 75 01	 lea	 r14d, QWORD PTR [rbp+1]
  0002e	85 ff		 test	 edi, edi
  00030	74 04		 je	 SHORT $LN5@uncompress

; 74   :         left = *destLen;
; 75   :         *destLen = 0;

  00032	89 2a		 mov	 DWORD PTR [rdx], ebp

; 76   :     }

  00034	eb 08		 jmp	 SHORT $LN6@uncompress
$LN5@uncompress:

; 77   :     else {
; 78   :         left = 1;

  00036	41 8b fe	 mov	 edi, r14d

; 79   :         dest = buf;

  00039	4c 8d 7c 24 20	 lea	 r15, QWORD PTR buf$[rsp]
$LN6@uncompress:

; 80   :     }
; 81   : 
; 82   :     stream.next_in = (z_const Bytef*)source;
; 83   :     stream.avail_in = 0;
; 84   :     stream.zalloc = (alloc_func)0;
; 85   :     stream.zfree = (free_func)0;
; 86   :     stream.opaque = (voidpf)0;
; 87   : 
; 88   :     err = inflateInit2(&stream, windowBits);

  0003e	8b 94 24 e0 00
	00 00		 mov	 edx, DWORD PTR windowBits$[rsp]
  00045	48 8d 4c 24 30	 lea	 rcx, QWORD PTR stream$[rsp]
  0004a	4c 89 44 24 30	 mov	 QWORD PTR stream$[rsp], r8
  0004f	41 b9 58 00 00
	00		 mov	 r9d, 88			; 00000058H
  00055	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06CJNJFBNP@1?42?411@
  0005c	89 6c 24 38	 mov	 DWORD PTR stream$[rsp+8], ebp
  00060	48 89 6c 24 60	 mov	 QWORD PTR stream$[rsp+48], rbp
  00065	48 89 6c 24 68	 mov	 QWORD PTR stream$[rsp+56], rbp
  0006a	48 89 6c 24 70	 mov	 QWORD PTR stream$[rsp+64], rbp
  0006f	e8 00 00 00 00	 call	 inflateInit2_

; 89   :     if (err != Z_OK) return err;

  00074	85 c0		 test	 eax, eax
  00076	0f 85 c8 00 00
	00		 jne	 $LN1@uncompress

; 90   : 
; 91   :     stream.next_out = dest;
; 92   :     stream.avail_out = 0;

  0007c	8b c5		 mov	 eax, ebp
  0007e	48 89 9c 24 c0
	00 00 00	 mov	 QWORD PTR [rsp+192], rbx
  00086	89 44 24 48	 mov	 DWORD PTR stream$[rsp+24], eax
  0008a	bd ff ff ff ff	 mov	 ebp, -1			; ffffffffH
  0008f	4c 89 7c 24 40	 mov	 QWORD PTR stream$[rsp+16], r15
$LL4@uncompress:

; 93   : 
; 94   :     do {
; 95   :         if (stream.avail_out == 0) {

  00094	85 c0		 test	 eax, eax
  00096	75 0d		 jne	 SHORT $LN8@uncompress

; 96   :             stream.avail_out = left > (uLong)max ? max : (uInt)left;

  00098	3b fd		 cmp	 edi, ebp
  0009a	8b c7		 mov	 eax, edi
  0009c	0f 47 c5	 cmova	 eax, ebp
  0009f	89 44 24 48	 mov	 DWORD PTR stream$[rsp+24], eax

; 97   :             left -= stream.avail_out;

  000a3	2b f8		 sub	 edi, eax
$LN8@uncompress:

; 98   :         }
; 99   :         if (stream.avail_in == 0) {

  000a5	83 7c 24 38 00	 cmp	 DWORD PTR stream$[rsp+8], 0
  000aa	75 0d		 jne	 SHORT $LN9@uncompress

; 100  :             stream.avail_in = len > (uLong)max ? max : (uInt)len;

  000ac	3b f5		 cmp	 esi, ebp
  000ae	8b c6		 mov	 eax, esi
  000b0	0f 47 c5	 cmova	 eax, ebp
  000b3	89 44 24 38	 mov	 DWORD PTR stream$[rsp+8], eax

; 101  :             len -= stream.avail_in;

  000b7	2b f0		 sub	 esi, eax
$LN9@uncompress:

; 102  :         }
; 103  :         err = inflate(&stream, Z_NO_FLUSH);

  000b9	33 d2		 xor	 edx, edx
  000bb	48 8d 4c 24 30	 lea	 rcx, QWORD PTR stream$[rsp]
  000c0	e8 00 00 00 00	 call	 inflate
  000c5	8b d8		 mov	 ebx, eax

; 104  :     } while (err == Z_OK);

  000c7	85 c0		 test	 eax, eax
  000c9	75 06		 jne	 SHORT $LN27@uncompress
  000cb	8b 44 24 48	 mov	 eax, DWORD PTR stream$[rsp+24]
  000cf	eb c3		 jmp	 SHORT $LL4@uncompress
$LN27@uncompress:

; 105  : 
; 106  :     *sourceLen -= len + stream.avail_in;

  000d1	8b 4c 24 38	 mov	 ecx, DWORD PTR stream$[rsp+8]

; 107  :     if (dest != buf)

  000d5	48 8d 44 24 20	 lea	 rax, QWORD PTR buf$[rsp]
  000da	03 ce		 add	 ecx, esi
  000dc	bd 00 00 00 00	 mov	 ebp, 0
  000e1	41 29 4d 00	 sub	 DWORD PTR [r13], ecx
  000e5	4c 3b f8	 cmp	 r15, rax
  000e8	74 24		 je	 SHORT $LN10@uncompress

; 108  :         *destLen = stream.total_out;

  000ea	8b 44 24 4c	 mov	 eax, DWORD PTR stream$[rsp+28]
  000ee	41 89 04 24	 mov	 DWORD PTR [r12], eax
$LN12@uncompress:

; 111  : 
; 112  :     inflateEnd(&stream);

  000f2	48 8d 4c 24 30	 lea	 rcx, QWORD PTR stream$[rsp]
  000f7	44 8b f7	 mov	 r14d, edi
  000fa	e8 00 00 00 00	 call	 inflateEnd

; 113  :     return err == Z_STREAM_END ? Z_OK :

  000ff	83 fb 01	 cmp	 ebx, 1
  00102	74 36		 je	 SHORT $LN15@uncompress
  00104	83 fb 02	 cmp	 ebx, 2
  00107	75 1c		 jne	 SHORT $LN16@uncompress
  00109	8d 6b fb	 lea	 ebp, QWORD PTR [rbx-5]
  0010c	eb 2c		 jmp	 SHORT $LN15@uncompress
$LN10@uncompress:

; 109  :     else if (stream.total_out && err == Z_BUF_ERROR)

  0010e	39 6c 24 4c	 cmp	 DWORD PTR stream$[rsp+28], ebp
  00112	74 de		 je	 SHORT $LN12@uncompress
  00114	83 fb fb	 cmp	 ebx, -5
  00117	75 d9		 jne	 SHORT $LN12@uncompress

; 110  :         left = 1;

  00119	48 8d 4c 24 30	 lea	 rcx, QWORD PTR stream$[rsp]
  0011e	e8 00 00 00 00	 call	 inflateEnd
  00123	eb 05		 jmp	 SHORT $LN23@uncompress
$LN16@uncompress:

; 113  :     return err == Z_STREAM_END ? Z_OK :

  00125	83 fb fb	 cmp	 ebx, -5
  00128	75 0e		 jne	 SHORT $LN14@uncompress
$LN23@uncompress:
  0012a	8b 4c 24 48	 mov	 ecx, DWORD PTR stream$[rsp+24]
  0012e	bd fd ff ff ff	 mov	 ebp, -3
  00133	41 03 ce	 add	 ecx, r14d
  00136	75 02		 jne	 SHORT $LN15@uncompress
$LN14@uncompress:
  00138	8b eb		 mov	 ebp, ebx
$LN15@uncompress:
  0013a	48 8b 9c 24 c0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+192]
  00142	8b c5		 mov	 eax, ebp
$LN1@uncompress:

; 114  :         err == Z_NEED_DICT ? Z_DATA_ERROR :
; 115  :         err == Z_BUF_ERROR && left + stream.avail_out ? Z_DATA_ERROR :
; 116  :         err;
; 117  : }

  00144	4c 8d 9c 24 90
	00 00 00	 lea	 r11, QWORD PTR [rsp+144]
  0014c	49 8b 6b 38	 mov	 rbp, QWORD PTR [r11+56]
  00150	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  00154	49 8b e3	 mov	 rsp, r11
  00157	41 5f		 pop	 r15
  00159	41 5e		 pop	 r14
  0015b	41 5d		 pop	 r13
  0015d	41 5c		 pop	 r12
  0015f	5f		 pop	 rdi
  00160	c3		 ret	 0
uncompress4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\hank2\source\repos\zlib\zlibaddons.c
;	COMDAT uncompress3
_TEXT	SEGMENT
dest$ = 64
destLen$ = 72
source$ = 80
sourceLen$ = 88
windowBits$ = 96
uncompress3 PROC					; COMDAT

; 125  : {

$LN4:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 126  :     return uncompress4(dest, destLen, source, &sourceLen, windowBits);

  00009	8b 44 24 60	 mov	 eax, DWORD PTR windowBits$[rsp]
  0000d	4c 8d 4c 24 58	 lea	 r9, QWORD PTR sourceLen$[rsp]
  00012	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00016	e8 00 00 00 00	 call	 uncompress4

; 127  : }

  0001b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001f	c3		 ret	 0
uncompress3 ENDP
_TEXT	ENDS
END
