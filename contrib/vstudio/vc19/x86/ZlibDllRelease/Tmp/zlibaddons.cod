; Listing generated by Microsoft (R) Optimizing Compiler Version 19.25.28614.0 

	TITLE	c:\users\hank2\source\repos\ulu\ulu\zlibaddons.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_06CJNJFBNP@1?42?411@			; `string'
CONST	ENDS
;	COMDAT ??_C@_06CJNJFBNP@1?42?411@
CONST	SEGMENT
??_C@_06CJNJFBNP@1?42?411@ DB '1.2.11', 00H		; `string'
CONST	ENDS
PUBLIC	_uncompress3@20
PUBLIC	_uncompress4@20
PUBLIC	_compress3@20
PUBLIC	_compress4@24
EXTRN	__chkstk:PROC
EXTRN	_memchr:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
; File C:\Users\hank2\source\repos\ULU\ULU\zlibaddons.c
;	COMDAT _compress4@24
_TEXT	SEGMENT
_stream$ = -56						; size = 56
_dest$ = 8						; size = 4
_destLen$ = 12						; size = 4
_source$ = 16						; size = 4
_sourceLen$ = 20					; size = 4
_level$ = 24						; size = 4
_windowBits$ = 28					; size = 4
_compress4@24 PROC					; COMDAT

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 12   :     z_stream stream;
; 13   :     int err;
; 14   :     const uInt max = (uInt)-1;
; 15   :     uLong left;
; 16   : 
; 17   :     left = *destLen;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _destLen$[ebp]
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b 38		 mov	 edi, DWORD PTR [eax]

; 18   :     *destLen = 0;
; 19   : 
; 20   :     stream.zalloc = (alloc_func)0;
; 21   :     stream.zfree = (free_func)0;
; 22   :     stream.opaque = (voidpf)0;
; 23   : 
; 24   :     err = deflateInit2(&stream, level, Z_DEFLATED, windowBits, MAX_MEM_LEVEL, Z_DEFAULT_STRATEGY);

  00011	6a 38		 push	 56			; 00000038H
  00013	68 00 00 00 00	 push	 OFFSET ??_C@_06CJNJFBNP@1?42?411@
  00018	6a 00		 push	 0
  0001a	6a 09		 push	 9
  0001c	ff 75 1c	 push	 DWORD PTR _windowBits$[ebp]
  0001f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00025	8d 44 24 24	 lea	 eax, DWORD PTR _stream$[esp+92]
  00029	6a 08		 push	 8
  0002b	ff 75 18	 push	 DWORD PTR _level$[ebp]
  0002e	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR _stream$[esp+132], 0
  00036	50		 push	 eax
  00037	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR _stream$[esp+140], 0
  0003f	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR _stream$[esp+144], 0
  00047	e8 00 00 00 00	 call	 _deflateInit2_@32

; 25   :     if (err != Z_OK) return err;

  0004c	85 c0		 test	 eax, eax
  0004e	0f 85 87 00 00
	00		 jne	 $LN1@compress4

; 26   : 
; 27   :     stream.next_out = dest;

  00054	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]

; 28   :     stream.avail_out = 0;

  00057	33 c9		 xor	 ecx, ecx

; 29   :     stream.next_in = (z_const Bytef*)source;
; 30   :     stream.avail_in = 0;

  00059	8b 75 14	 mov	 esi, DWORD PTR _sourceLen$[ebp]
  0005c	33 d2		 xor	 edx, edx
  0005e	89 44 24 1c	 mov	 DWORD PTR _stream$[esp+84], eax
  00062	8b 45 10	 mov	 eax, DWORD PTR _source$[ebp]
  00065	89 4c 24 20	 mov	 DWORD PTR _stream$[esp+88], ecx
  00069	89 44 24 10	 mov	 DWORD PTR _stream$[esp+72], eax
  0006d	89 54 24 14	 mov	 DWORD PTR _stream$[esp+76], edx
$LN16@compress4:

; 31   : 
; 32   :     do {
; 33   :         if (stream.avail_out == 0) {

  00071	83 cb ff	 or	 ebx, -1
  00074	85 c9		 test	 ecx, ecx
  00076	75 0d		 jne	 SHORT $LN6@compress4

; 34   :             stream.avail_out = left > (uLong)max ? max : (uInt)left;

  00078	3b fb		 cmp	 edi, ebx
  0007a	8b c7		 mov	 eax, edi
  0007c	0f 47 c3	 cmova	 eax, ebx
  0007f	89 44 24 20	 mov	 DWORD PTR _stream$[esp+88], eax

; 35   :             left -= stream.avail_out;

  00083	2b f8		 sub	 edi, eax
$LN6@compress4:

; 36   :         }
; 37   :         if (stream.avail_in == 0) {

  00085	85 d2		 test	 edx, edx
  00087	75 0e		 jne	 SHORT $LN7@compress4

; 38   :             stream.avail_in = sourceLen > (uLong)max ? max : (uInt)sourceLen;

  00089	83 fe ff	 cmp	 esi, -1
  0008c	8b c6		 mov	 eax, esi
  0008e	0f 47 c3	 cmova	 eax, ebx
  00091	89 44 24 14	 mov	 DWORD PTR _stream$[esp+76], eax

; 39   :             sourceLen -= stream.avail_in;

  00095	2b f0		 sub	 esi, eax
$LN7@compress4:

; 40   :         }
; 41   :         err = deflate(&stream, sourceLen ? Z_NO_FLUSH : Z_FINISH);

  00097	33 c9		 xor	 ecx, ecx
  00099	b8 04 00 00 00	 mov	 eax, 4
  0009e	85 f6		 test	 esi, esi
  000a0	0f 45 c1	 cmovne	 eax, ecx
  000a3	50		 push	 eax
  000a4	8d 44 24 14	 lea	 eax, DWORD PTR _stream$[esp+76]
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 _deflate@8
  000ae	8b d8		 mov	 ebx, eax

; 42   :     } while (err == Z_OK);

  000b0	85 db		 test	 ebx, ebx
  000b2	75 0a		 jne	 SHORT $LN15@compress4
  000b4	8b 4c 24 20	 mov	 ecx, DWORD PTR _stream$[esp+88]
  000b8	8b 54 24 14	 mov	 edx, DWORD PTR _stream$[esp+76]
  000bc	eb b3		 jmp	 SHORT $LN16@compress4
$LN15@compress4:

; 43   : 
; 44   :     *destLen = stream.total_out;

  000be	8b 4d 0c	 mov	 ecx, DWORD PTR _destLen$[ebp]
  000c1	8b 44 24 24	 mov	 eax, DWORD PTR _stream$[esp+92]
  000c5	89 01		 mov	 DWORD PTR [ecx], eax

; 45   :     deflateEnd(&stream);

  000c7	8d 44 24 10	 lea	 eax, DWORD PTR _stream$[esp+72]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 _deflateEnd@4

; 46   :     return err == Z_STREAM_END ? Z_OK : err;

  000d1	33 c0		 xor	 eax, eax
  000d3	83 fb 01	 cmp	 ebx, 1
  000d6	0f 44 d8	 cmove	 ebx, eax
  000d9	8b c3		 mov	 eax, ebx
$LN1@compress4:

; 47   : }

  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi
  000dd	5b		 pop	 ebx
  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c2 18 00	 ret	 24			; 00000018H
_compress4@24 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\hank2\source\repos\ULU\ULU\zlibaddons.c
;	COMDAT _compress3@20
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_destLen$ = 12						; size = 4
_source$ = 16						; size = 4
_sourceLen$ = 20					; size = 4
_windowBits$ = 24					; size = 4
_compress3@20 PROC					; COMDAT

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 56   :     return compress4(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION, windowBits);

  00003	ff 75 18	 push	 DWORD PTR _windowBits$[ebp]
  00006	6a ff		 push	 -1
  00008	ff 75 14	 push	 DWORD PTR _sourceLen$[ebp]
  0000b	ff 75 10	 push	 DWORD PTR _source$[ebp]
  0000e	ff 75 0c	 push	 DWORD PTR _destLen$[ebp]
  00011	ff 75 08	 push	 DWORD PTR _dest$[ebp]
  00014	e8 00 00 00 00	 call	 _compress4@24

; 57   : }

  00019	5d		 pop	 ebp
  0001a	c2 14 00	 ret	 20			; 00000014H
_compress3@20 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\hank2\source\repos\ULU\ULU\zlibaddons.c
;	COMDAT _uncompress4@20
_TEXT	SEGMENT
_buf$ = -57						; size = 1
_stream$ = -56						; size = 56
_dest$ = 8						; size = 4
_destLen$ = 12						; size = 4
_source$ = 16						; size = 4
_sourceLen$ = 20					; size = 4
_windowBits$ = 24					; size = 4
_uncompress4@20 PROC					; COMDAT

; 65   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H

; 66   :     z_stream stream;
; 67   :     int err;
; 68   :     const uInt max = (uInt)-1;
; 69   :     uLong len, left;
; 70   :     Byte buf[1];    /* for detection of incomplete stream when *destLen == 0 */
; 71   : 
; 72   :     len = *sourceLen;
; 73   :     if (*destLen) {

  00006	8b 45 0c	 mov	 eax, DWORD PTR _destLen$[ebp]
  00009	83 ec 3c	 sub	 esp, 60			; 0000003cH
  0000c	53		 push	 ebx
  0000d	8b 5d 14	 mov	 ebx, DWORD PTR _sourceLen$[ebp]
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b 38		 mov	 edi, DWORD PTR [eax]
  00014	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  00016	85 ff		 test	 edi, edi
  00018	74 0b		 je	 SHORT $LN5@uncompress

; 74   :         left = *destLen;
; 75   :         *destLen = 0;
; 76   :     }

  0001a	8b 75 08	 mov	 esi, DWORD PTR _dest$[ebp]
  0001d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00023	eb 0c		 jmp	 SHORT $LN6@uncompress
$LN5@uncompress:

; 77   :     else {
; 78   :         left = 1;
; 79   :         dest = buf;

  00025	8d 74 24 0f	 lea	 esi, DWORD PTR _buf$[esp+72]
  00029	bf 01 00 00 00	 mov	 edi, 1
  0002e	89 75 08	 mov	 DWORD PTR _dest$[ebp], esi
$LN6@uncompress:

; 80   :     }
; 81   : 
; 82   :     stream.next_in = (z_const Bytef*)source;

  00031	8b 45 10	 mov	 eax, DWORD PTR _source$[ebp]

; 83   :     stream.avail_in = 0;
; 84   :     stream.zalloc = (alloc_func)0;
; 85   :     stream.zfree = (free_func)0;
; 86   :     stream.opaque = (voidpf)0;
; 87   : 
; 88   :     err = inflateInit2(&stream, windowBits);

  00034	6a 38		 push	 56			; 00000038H
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_06CJNJFBNP@1?42?411@
  0003b	ff 75 18	 push	 DWORD PTR _windowBits$[ebp]
  0003e	89 44 24 1c	 mov	 DWORD PTR _stream$[esp+84], eax
  00042	8d 44 24 1c	 lea	 eax, DWORD PTR _stream$[esp+84]
  00046	50		 push	 eax
  00047	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _stream$[esp+92], 0
  0004f	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR _stream$[esp+120], 0
  00057	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR _stream$[esp+124], 0
  0005f	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR _stream$[esp+128], 0
  00067	e8 00 00 00 00	 call	 _inflateInit2_@16

; 89   :     if (err != Z_OK) return err;

  0006c	85 c0		 test	 eax, eax
  0006e	0f 85 b6 00 00
	00		 jne	 $LN1@uncompress

; 90   : 
; 91   :     stream.next_out = dest;

  00074	89 74 24 1c	 mov	 DWORD PTR _stream$[esp+84], esi

; 92   :     stream.avail_out = 0;

  00078	89 44 24 20	 mov	 DWORD PTR _stream$[esp+88], eax
$LN28@uncompress:

; 93   : 
; 94   :     do {
; 95   :         if (stream.avail_out == 0) {

  0007c	83 c9 ff	 or	 ecx, -1
  0007f	85 c0		 test	 eax, eax
  00081	75 0d		 jne	 SHORT $LN8@uncompress

; 96   :             stream.avail_out = left > (uLong)max ? max : (uInt)left;

  00083	3b f9		 cmp	 edi, ecx
  00085	8b c7		 mov	 eax, edi
  00087	0f 47 c1	 cmova	 eax, ecx
  0008a	89 44 24 20	 mov	 DWORD PTR _stream$[esp+88], eax

; 97   :             left -= stream.avail_out;

  0008e	2b f8		 sub	 edi, eax
$LN8@uncompress:

; 98   :         }
; 99   :         if (stream.avail_in == 0) {

  00090	83 7c 24 14 00	 cmp	 DWORD PTR _stream$[esp+76], 0
  00095	75 0e		 jne	 SHORT $LN9@uncompress

; 100  :             stream.avail_in = len > (uLong)max ? max : (uInt)len;

  00097	83 fb ff	 cmp	 ebx, -1
  0009a	8b c3		 mov	 eax, ebx
  0009c	0f 47 c1	 cmova	 eax, ecx
  0009f	89 44 24 14	 mov	 DWORD PTR _stream$[esp+76], eax

; 101  :             len -= stream.avail_in;

  000a3	2b d8		 sub	 ebx, eax
$LN9@uncompress:

; 102  :         }
; 103  :         err = inflate(&stream, Z_NO_FLUSH);

  000a5	6a 00		 push	 0
  000a7	8d 44 24 14	 lea	 eax, DWORD PTR _stream$[esp+76]
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 _inflate@8
  000b1	8b f0		 mov	 esi, eax

; 104  :     } while (err == Z_OK);

  000b3	85 f6		 test	 esi, esi
  000b5	75 06		 jne	 SHORT $LN27@uncompress
  000b7	8b 44 24 20	 mov	 eax, DWORD PTR _stream$[esp+88]
  000bb	eb bf		 jmp	 SHORT $LN28@uncompress
$LN27@uncompress:

; 105  : 
; 106  :     *sourceLen -= len + stream.avail_in;

  000bd	8b 4d 14	 mov	 ecx, DWORD PTR _sourceLen$[ebp]
  000c0	8b 44 24 14	 mov	 eax, DWORD PTR _stream$[esp+76]
  000c4	03 c3		 add	 eax, ebx
  000c6	29 01		 sub	 DWORD PTR [ecx], eax

; 107  :     if (dest != buf)

  000c8	8d 44 24 0f	 lea	 eax, DWORD PTR _buf$[esp+72]
  000cc	39 45 08	 cmp	 DWORD PTR _dest$[ebp], eax
  000cf	74 25		 je	 SHORT $LN10@uncompress

; 108  :         *destLen = stream.total_out;

  000d1	8b 4d 0c	 mov	 ecx, DWORD PTR _destLen$[ebp]
  000d4	8b 44 24 24	 mov	 eax, DWORD PTR _stream$[esp+92]
  000d8	89 01		 mov	 DWORD PTR [ecx], eax
$LN12@uncompress:

; 111  : 
; 112  :     inflateEnd(&stream);

  000da	8d 44 24 10	 lea	 eax, DWORD PTR _stream$[esp+72]
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 _inflateEnd@4

; 113  :     return err == Z_STREAM_END ? Z_OK :

  000e4	83 fe 01	 cmp	 esi, 1
  000e7	75 28		 jne	 SHORT $LN18@uncompress
  000e9	33 f6		 xor	 esi, esi
  000eb	8b c6		 mov	 eax, esi

; 114  :         err == Z_NEED_DICT ? Z_DATA_ERROR :
; 115  :         err == Z_BUF_ERROR && left + stream.avail_out ? Z_DATA_ERROR :
; 116  :         err;
; 117  : }

  000ed	5f		 pop	 edi
  000ee	5e		 pop	 esi
  000ef	5b		 pop	 ebx
  000f0	8b e5		 mov	 esp, ebp
  000f2	5d		 pop	 ebp
  000f3	c2 14 00	 ret	 20			; 00000014H
$LN10@uncompress:

; 109  :     else if (stream.total_out && err == Z_BUF_ERROR)

  000f6	83 7c 24 24 00	 cmp	 DWORD PTR _stream$[esp+92], 0
  000fb	74 dd		 je	 SHORT $LN12@uncompress
  000fd	83 fe fb	 cmp	 esi, -5			; fffffffbH
  00100	75 d8		 jne	 SHORT $LN12@uncompress

; 110  :         left = 1;

  00102	8d 44 24 10	 lea	 eax, DWORD PTR _stream$[esp+72]
  00106	50		 push	 eax
  00107	8d 7e 06	 lea	 edi, DWORD PTR [esi+6]
  0010a	e8 00 00 00 00	 call	 _inflateEnd@4
  0010f	eb 0a		 jmp	 SHORT $LN23@uncompress
$LN18@uncompress:

; 113  :     return err == Z_STREAM_END ? Z_OK :

  00111	83 fe 02	 cmp	 esi, 2
  00114	74 0d		 je	 SHORT $LN29@uncompress
  00116	83 fe fb	 cmp	 esi, -5			; fffffffbH
  00119	75 0d		 jne	 SHORT $LN15@uncompress
$LN23@uncompress:
  0011b	8b 44 24 20	 mov	 eax, DWORD PTR _stream$[esp+88]
  0011f	03 c7		 add	 eax, edi
  00121	74 05		 je	 SHORT $LN15@uncompress
$LN29@uncompress:
  00123	be fd ff ff ff	 mov	 esi, -3			; fffffffdH
$LN15@uncompress:
  00128	8b c6		 mov	 eax, esi
$LN1@uncompress:

; 114  :         err == Z_NEED_DICT ? Z_DATA_ERROR :
; 115  :         err == Z_BUF_ERROR && left + stream.avail_out ? Z_DATA_ERROR :
; 116  :         err;
; 117  : }

  0012a	5f		 pop	 edi
  0012b	5e		 pop	 esi
  0012c	5b		 pop	 ebx
  0012d	8b e5		 mov	 esp, ebp
  0012f	5d		 pop	 ebp
  00130	c2 14 00	 ret	 20			; 00000014H
_uncompress4@20 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\hank2\source\repos\ULU\ULU\zlibaddons.c
;	COMDAT _uncompress3@20
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_destLen$ = 12						; size = 4
_source$ = 16						; size = 4
_sourceLen$ = 20					; size = 4
_windowBits$ = 24					; size = 4
_uncompress3@20 PROC					; COMDAT

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 126  :     return uncompress4(dest, destLen, source, &sourceLen, windowBits);

  00003	ff 75 18	 push	 DWORD PTR _windowBits$[ebp]
  00006	8d 45 14	 lea	 eax, DWORD PTR _sourceLen$[ebp]
  00009	50		 push	 eax
  0000a	ff 75 10	 push	 DWORD PTR _source$[ebp]
  0000d	ff 75 0c	 push	 DWORD PTR _destLen$[ebp]
  00010	ff 75 08	 push	 DWORD PTR _dest$[ebp]
  00013	e8 00 00 00 00	 call	 _uncompress4@20

; 127  : }

  00018	5d		 pop	 ebp
  00019	c2 14 00	 ret	 20			; 00000014H
_uncompress3@20 ENDP
_TEXT	ENDS
END
